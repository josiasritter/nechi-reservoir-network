%% Daily Target electricity generation of the hydropower dam cascade in the Nechí catchment (Colombia)
% and allocation to the of 4 dams

% Author: Josias Ritter (The Nature Conservancy), ritterjosias@gmail.com
% August 2016


% INPUTS (ALL GENERATED BY 'Cascade_HUB_vs16.m'):
%================================================
% t                                                         : current time step
% volumeTS of M,G & T                                       : useful volumes resulting from preliminary WB
% volumeTS_pred of P2 & P3                                  : estimiated useful volumes resulting from preliminary WB
% maxvol of all five reservoirs                             : useful capacities
% nethead_pred_P3                                           : estimated head in P3 resulting from preliminary WB
% installedPower of all six individual PPs
% maxGen                                                    : sum of all installed capacities
% inputMonth                                                : current month of the year
% Qin_monthly_mean                                          : multiannual monthly means of total system inflow
% monthly_Qmin_nat                                          : minimum discharge ever observed in months of the year
% enso                                                      : ENSO ONI signal with 2 month delay (El Niño/La Niña)
% price_ratio_monthly_mean                                  : multiannual ratio of monthly to yearly Bolsa energy price
% drywet_ind                                                : 7-day-moving average of total system inflows
% optpars                                                   : values of 11 decision variables from GODLIKE (see below)


% OUTPUTS (ALL RETURNED TO 'Cascade_HUB_vs16.m'):
%===============================================
% targetGen_TOTAL                                           : lumped generation target for entire cascade [0;1]
% targetGen_G                                               : allocated generation targets for individual dams [0;1]
% targetGen_T
% targetGen_P2
% targetGen_P3
% targetGen_TOT_adj                                         : overall target for entire cascade after allocation [0;1]


% PARAMETERS FOR OPTIMISATION AND THEIR THEORETICAL RANGES (optpars):
%====================================================================
% drywet_thrshld [0;250]      : threshold of mean discharge over the last 7 days that determines between dry/wet season
% parQ [0;23.6]               : release curve of Miraflores (in Cascade_HUB)
% G_filling_crit [0;1]        : in dry season, flow from M to GT = maxflow_M when filling of Troneras lower (Cascade_HUB)
% p1 [0;15]                   : determining weight decline in inflow forecast (ranking method)
% op1 [0;1]                   : weight of w_cascadefill_ind in computation of targetGen_TOTAL
% op2 [0;1]                   : weight of price_ind in computation of targetGen_TOTAL
% op3 [0;1]                   : weight of forecast_ind in computation of targetGen_TOTAL. Weight of lanina_ind is relative
% flood_targetfill_P3 [0;1]   : target filling of Porce 3 in rainy season
% flood_targetfill_P2 [0;1]   : target filling of Porce 2 in rainy season
% alloc_weight [0;1]          : weights between indicators in while loop of tagetGen_TOTAL allocation to individual PPs
% minFlowP3_w [0;2]           : factor for the minimum outflow from Porce 3 


%% Function

function[targetGen_TOTAL, targetGen_TOT_adj, targetGen_G, targetGen_T, targetGen_P2, targetGen_P3] = ...
    targetGen_vs7_train(t,volumeTS_M,maxvol_M,volumeTS_G,maxvol_G,volumeTS_T,maxvol_T,...
    volumeTS_pred_P2,maxvol_P2,volumeTS_pred_P3,maxvol_P3,nethead_pred_P3,...
    installedPower_GT,installedPower_G3,installedPower_G4,...
    installedPower_T,installedPower_P2,installedPower_P3,maxGen, ... 
    inputMonth,Qin_monthly_mean,monthly_Qmin_nat,enso,price_ratio_monthly_mean,drywet_ind,optpars)

    drywet_thrshld = optpars(1);
    p1 = optpars(4);
    op1 = optpars(5);
    op2 = optpars(6);
    op3 = optpars(7);
    flood_targetfill_P3 = optpars(8);
    flood_targetfill_P2 = optpars(9);
    alloc_weight = optpars(10);
    minFlowP3_w = optpars (11);


%% Generation of global targetGen_TOTAL            
        
    % Indicators 

        % 1. Weighted filling percentage of cascade (water in upstream dams has more weight)
            % Sums of installed capacity downstream of reservoirs 
            potE_P3 = installedPower_P3;
            potE_P2 = potE_P3 + installedPower_P2;
            potE_T = potE_P2 + installedPower_T;
            potE_G = potE_P3 + installedPower_GT + installedPower_G3 + installedPower_G4;
            potE_M = potE_G; 
            potE_TOT = potE_P3 + potE_P2 + potE_T + potE_G + potE_M;

            w_cascadefill_ind = (potE_M/potE_TOT * volumeTS_M(t) + ...
                potE_G/potE_TOT * volumeTS_G(t) + potE_T/potE_TOT * volumeTS_T(t) + ...
                potE_P2/potE_TOT * volumeTS_pred_P2(t) + potE_P3/potE_TOT * volumeTS_pred_P3(t)) / ...
                (potE_M/potE_TOT * maxvol_M + potE_G/potE_TOT * maxvol_G + ...
                potE_T/potE_TOT * maxvol_T + potE_P2/potE_TOT * maxvol_P2 + ...
                potE_P3/potE_TOT * maxvol_P3);


        % 2. Multiannual (2002-2011) monthly means of Bolsa energy price related to yearly means
            % Normalisation of values to [0;1], rest of calculation in inputReader_vs5
            price_ind = (price_ratio_monthly_mean(inputMonth(t)) - min(price_ratio_monthly_mean)) ...
                / (max(price_ratio_monthly_mean) - min(price_ratio_monthly_mean));


        % 3. Seasonal inflow forecast as current and following 3 months with weights of ranking method
            % ranks: 1. current month; 2. current month + 1; 3. current month + 2; 4. current month + 3
            % p1 = [0;15] parameter for optimisation 

            % Sets variables
            d = zeros(4,1);
            w = zeros(4,1);
            G = zeros(12,1);

            % Weights according to the Ranking Method
            for j = 1:4
                d(j) = (4-j+1)^p1;
            end
            for f = 1:4
                w(f) = d(f)/ sum(d);
            end

            % Apply weights to months
            for g = 1:12
                G(g) = w(1)*Qin_monthly_mean(g) +  w(2)*Qin_monthly_mean(g+1) + ...
                    w(3)*Qin_monthly_mean(g+2) +  w(4)*Qin_monthly_mean(g+3);
            end

            % Weigted sum and normalisation to [0;1]       
            forecast_ind = ((w(1)*Qin_monthly_mean(inputMonth(t)) + ...
                w(2)*Qin_monthly_mean(inputMonth(t)+1) + w(3)*Qin_monthly_mean(inputMonth(t)+2) + ...
                w(4)*Qin_monthly_mean(inputMonth(t)+3)) - min(G)) / (max(G)-min(G));


        % 4. Influence of El Niño/La Niña using ONI signal of 3-month moving avg until current month
            % Inverting signal
            enso_minus = enso * (-1);
            % Normalisation to [0;1]
            lanina_ind = (enso_minus(t) - min(enso_minus)) / (max(enso_minus) - min(enso_minus));


    % Function combining all indicators into one value of targetGen_TOTAL [0;1]
        % Weighted sum of indicators. Weights op1, op2 and op3 [0;1] as dec. vars to explore relevance
        % lanina_ind expressed as relative weight, to save a decision variable

        targetGen_TOTAL = (op1 * w_cascadefill_ind + (1-op1) * op2 * price_ind + (1-op1-(1-op1)*op2) ...
            * op3 * forecast_ind + (1-op1-(1-op1)*op2-(1-op1-(1-op1)*op2)*op3) * lanina_ind); 

    
%% Market demand

    % Generation under market influence
    % expressed as normally distributed around previously calculated tergetGen_TOTAL

        targetGen_TOTAL = normrnd(targetGen_TOTAL,targetGen_TOTAL/20); % Value for std dev questionable

        if targetGen_TOTAL > 1
            targetGen_TOTAL = 1;
        else if targetGen_TOTAL < 0
            targetGen_TOTAL = 0;
            end
        end
       
%% Distribution of global targetGen_TOTAL to local PPs [as percentages of intalledPower]

        % Sets variables:
        targetGen_G = 0;
        targetGen_T = 0;
        targetGen_P2 = 0;

        % Minimum target for P3 to avoide low flows 
        % using (minimum total natural inflow ever observed in current month of year)
        % minFlowP3_w as opt. par. to explore importance of rule
        targetGen_P3 = minFlowP3_w * (9800 * nethead_pred_P3 * ...
            (monthly_Qmin_nat(inputMonth(t)) - 2) * 0.89 / (installedPower_P3 * 1e6)); 


        % Filling percentages of reservoirs
        filling = zeros(4,1);
        filling(1) = volumeTS_G(t+1)/maxvol_G;   
        filling(2) = volumeTS_T(t+1)/maxvol_T;
        filling(3) = volumeTS_pred_P2(t+1)/maxvol_P2;
        filling(4) = volumeTS_pred_P3(t+1)/maxvol_P3;

        % Weights for giving higher targets to downstream reservoirs (for flood protection) 
        DwnstrToUpstr = zeros(4,1);
        DwnstrToUpstr(1) = 1 - potE_G/(potE_TOT-potE_M);
        DwnstrToUpstr(2) = 1 - potE_T/(potE_TOT-potE_M);
        DwnstrToUpstr(3) = 1 - potE_P2/(potE_TOT-potE_M);
        DwnstrToUpstr(4) = 1 - potE_P3/(potE_TOT-potE_M);

    
    % Constraints leading to targetGen = 1 (hard constraints) 

        % Flood buffer rules (buffer in Porce 3 & Porce 2 in rainy season from April to December)
        % Check if wet season
        if inputMonth(t) > 3 && drywet_ind(t) > drywet_thrshld
            % Check filling percentages
            if filling(4) > flood_targetfill_P3     % flood_targetfill_P3 as decision var. [0;1]
                targetGen_P3 = 1;
            end
            if filling(3) > flood_targetfill_P2     % flood_targetfill_P2 as decision var. [0;1]
                targetGen_P2 = 1;
            end
        end 

        % Full reservoir rule: 
        if volumeTS_pred_P3(t+1) >= maxvol_P3
            targetGen_P3 = 1;
        end
        if volumeTS_pred_P2(t+1) >= maxvol_P2
            targetGen_P2 = 1;
        end
        if volumeTS_T(t+1) >= maxvol_T
            targetGen_T = 1;
        end
        if volumeTS_G(t+1) >= maxvol_G
            targetGen_G = 1;
        end      

    % Check how much power has still to be allocated    
    targetPower_TOTAL = targetGen_TOTAL * maxGen;
    targetPower_remaining = max(0,targetPower_TOTAL - targetGen_P3*installedPower_P3 - ...
        targetGen_P2*installedPower_P2 - targetGen_T*installedPower_T - ...
        targetGen_G*(installedPower_GT+installedPower_G3+installedPower_G4));

        % Check wich PPs still have capacity to generate
        logInd = zeros(4,1);
        logInd(1) = targetGen_G < 1;
        logInd(2) = targetGen_T < 1;
        logInd(3) = targetGen_P2 < 1;
        logInd(4) = targetGen_P3 < 1;

        filling = logInd .* filling;  
        DwnstrToUpstr = logInd .* DwnstrToUpstr;

    % While loop allocating until everything allocated    
    while targetPower_remaining > 0 && sum(logInd) > 0

        % Constraints allocating targetPower_remaining

        % Allocate acc. to filling, and position (downstream reservoirs higher weights 
        % Omitting PPs that have already target = 1
        % alloc_weight as decision variable exploring the weight between the two allocation indicators  
        Pshare = zeros(4,1);
        for j = 1:4
            if logInd(j) > 0
                Pshare(j) = (alloc_weight * filling(j)/sum(filling) + ...
                    (1-alloc_weight) * DwnstrToUpstr(j)/sum(DwnstrToUpstr));
            end
        end

        targetGen_G = targetGen_G + Pshare(1) * targetPower_remaining / ...
            (installedPower_GT + installedPower_G3 + installedPower_G4);
        targetGen_T = targetGen_T + Pshare(2) * targetPower_remaining / installedPower_T;
        targetGen_P2 = targetGen_P2 + Pshare(3) * targetPower_remaining / installedPower_P2;
        targetGen_P3 = targetGen_P3 + Pshare(4) * targetPower_remaining / installedPower_P3;


        % Check if too much was allocated to a PP 
        defPower_G = 0;
        defPower_T = 0;
        defPower_P2 = 0;
        defPower_P3 = 0;

        if targetGen_G > 1
            defPower_G = (targetGen_G - 1) * ...
                (installedPower_GT + installedPower_G3 + installedPower_G4);
            targetGen_G = 1;
        end    
        if targetGen_T > 1
            defPower_T = (targetGen_T - 1) * installedPower_T;
            targetGen_T = 1;
        end    
        if targetGen_P2 > 1
            defPower_P2 = (targetGen_P2 - 1) * installedPower_P2;
            targetGen_P2 = 1;
        end    
        if targetGen_P3 > 1
            defPower_P3 = (targetGen_P3 - 1) * installedPower_P3;
            targetGen_P3 = 1;
        end


        % Constraint avoiding targetGen below minEn, as turbines are ineffective with low targets 
        % Porce 3 is excluded for reducing flow alteration
        % minimum allowed target (manually calibrated):
        minEn=0.1;                                                              
        if targetGen_G < minEn
            defPower_P2 = (targetGen_G) * (installedPower_GT + installedPower_G3 + installedPower_G4);
            targetGen_G = 0;
        end
        if targetGen_T < minEn
            defPower_T = (targetGen_T) * installedPower_T;
            targetGen_T = 0;
        end
        if targetGen_P2 < minEn
            defPower_P2 = (targetGen_P2) * installedPower_P2;
            targetGen_P2 = 0;   
        end


        % Feed wrong allocations back to targetPower_remaining
        targetPower_remaining = defPower_G + defPower_T + defPower_P2 + defPower_P3;


        % Check wich PPs still have power capacity and are not intentionally = 0 due to small target
        logInd = zeros(4,1);
        logInd(1) = targetGen_G < 1 & targetGen_G > 0;
        logInd(2) = targetGen_T < 1 & targetGen_T > 0;
        logInd(3) = targetGen_P2 < 1 & targetGen_P2 > 0;
        logInd(4) = targetGen_P3 < 1;

        % Reset allocation indicators
        filling = logInd .* filling;
        DwnstrToUpstr = logInd .* DwnstrToUpstr;
    end


% Adjusting targetGen_TOTAL after allocation
targetGen_TOT_adj = (targetGen_P3*installedPower_P3 + targetGen_P2*installedPower_P2 + ...
    targetGen_T*installedPower_T ...
    + targetGen_G*(installedPower_GT+installedPower_G3+installedPower_G4))/maxGen;
    
end